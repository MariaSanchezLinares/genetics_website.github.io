{"title":"GWAS Implementation","markdown":{"yaml":{"title":"GWAS Implementation","format":"html"},"headingText":"Preparation","containsRefs":false,"markdown":"\n\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(echo = TRUE, error = TRUE)\nlibrary(survival)\nlibrary(Matrix)\nlibrary(snpStats)\n```\n\nIn this section we will learn how to perform a Genome-Wide Association study in R using marginal regression, and how to visualize our results using Manhattan plots. \n\n\nTo prepare for this task you will need to install (or update) the following packages:\n\n```{r load-packages}\n#| message: false\nlibrary(tidyverse)\nlibrary(broom)\nlibrary(qqman)\nlibrary(RColorBrewer)\n```\n\nWe will also need the `snpStats`. The installation process for the package is slightly different:\n\n```{r install-from-bioconductor}\n#| eval: false\n\n# installing the package\nif (!require(\"BiocManager\", quietly = TRUE))\n    install.packages(\"BiocManager\")\n\nBiocManager::install(\"snpStats\")\n\n# load the snpStats package\nlibrary(snpStats)\n```\n\n\n## Data: exploration and prep\n\nWe will be using real genotype data and a simulated binary phenotype from the International HapMap Project, specifically from 165 individuals.The data only includes individuals from Utah with Northern and Western European ancestry (the \"CEU\" population).\n\nThe data is available in the *PLINK format* and are stored in three files:\n\n- `.bed` – genotype information\n- `.fam` – individual-level information\n- `.bim` – SNP details\n\n::: callout-note!\n`PLINK` is a tool for analyzing genetic data and conducting GWAS. Learn more [here](https://www.cog-genomics.org/plink/). We’re going to be conducting our GWAS \"by hand\", but in practice most people use `PLINK` or other software programs instead. \n:::\n\nWe can use the `read.plink` function in the `snpStats` package to read these data into R. \n\n```{r file-paths}\n# update file paths\ngwas.dir <- './1_QC_GWAS/HapMap_3_r3_1'\n\nbed <- paste0(gwas.dir, '.bed')\nbim <- paste0(gwas.dir, '.bim')\nfam <- paste0(gwas.dir, '.fam')\n```\n\n\n```{r read-data}\n#| cache: true\n# NOTE: this might take a minute or two\nhapmap <- snpStats::read.plink(bed, bim, fam)\n\n```\n\n### Understanding the data\n\nThe `hapmap` data object we have created is a \"list\" containing the three items described above. \n\n```{r explore-data}\nclass(hapmap)\nnames(hapmap)\n```\n\nThe dataset contains 165 people and 1,457,897 SNPs\n\n```{r}\ndim(hapmap$genotypes)\n```\n\n\nBut what do we know about each individual? The `fam` file keeps track of information about each of the people in our study, see a glossary below:\n\n```{r explore-sample-info}\nhead(hapmap$fam)\n```\n\n-   `pedigree`: the family ID number, ie the ID of the family, or \"pedigree\", to which this individual belongs\n-   `member`: the individual ID number \n-   `father`: the ID of the individual's father, if known **and** present in this sample (`NA` otherwise)\n-   `mother`: the ID of the individual's mother, if known and present in this sample (`NA` otherwise)\n-   `sex`: binary sex (`1` = male, `2` = female, `0` = unknown)\n-   `affected`: a binary simulated phenotype (`1` = control, `2` = case)\n\nThe `.map` file contains information about the different SNPs: \n\n```{r explore-snp-info}\nhead(hapmap$map)\n```\n\n-   `chromosome`: the chromosome on which the SNP resides\n-   `snp.name`: the name of the SNP (commonly referred to as the \"rsID\")\n-   `cM`: or *centiMorgans*; how far about SNPs are from one another along the genome, also known as \"genetic distance\"\n-   `position`: physical (base pair) distance, position of the SNP (e.g., position = 1 would be the very first nucleotide in our DNA sequence)\n-   `allele.1`: one of the alleles at this SNP (according to the `PLINK` documentation, this is *usually* the minor allele)\n-   `allele.2`: other allele at this SNP (according to the `PLINK` documentation, this is *usually* the major allele)\n\n\n### Format data for analysis \n\nLet's add a minor allele frequencies to our `map` data frame. (This will come in handy later!)\n\n```{r add-MAF-to-SNP-info}\nmaf <- col.summary(hapmap$genotypes)$MAF\n\n# add new MAF variable \nhapmap$map <- hapmap$map %>%\n  mutate(MAF = maf)\n\n# look at SNP info again\nhead(hapmap$map)\n```\n\nThe `snpstats` package uses a unique format to store data. Currently, genotypes are coded as 01, 02, and 03 (with 00 representing missing values). Let's convert this to the 0, 1, 2 (and NA) format \n\n```{r reformat-genotypes}\n# what type of object is hapmap$genotypes\nclass(hapmap$genotypes)\n\n# convert from \"SnpMatrix\" to \"numeric\"\nX <- as(hapmap$genotypes, \"numeric\")\n\n# what type of object do we have now \nclass(X)\n\n# look at first five rows/columns to confirm conversion looks ok\nX[1:5, 1:5]\n```\n\nYou should now see a matrix of 0's, 1's, and 2's!\n\n## Trait Simulation\n\n### Background\n\nFor the purpose of this task, we will create artificial data where we already know the \"truth,\" then run a statistical method on it to see how well it performs.Since we designed the data, we can compare the method’s results to the known truth, allowing us to evaluate its accuracy. \n\nSimulation studies are a widely used technique in statistical research, as they are especially helpful when testing new methods, exploring how they behave in different situations, or comparing multiple approaches. It’s also a great workaround when getting real data can be tricky. \n\n### Picking a causal SNP\n\nLet's simulate a trait that depends on the SNP known as *rs2476601*. Here's what we know about this SNP: \n\n```{r look-at-causal-SNP}\nhapmap$map %>%\n  filter(snp.name == 'rs2476601')\n```\n\n### Simulating a quantitative trait\n\nNow, let's create a quantitative trait `y` that depends on your genotype at this SNP plus some random noise. We'll give this SNP an \"effect size\" of 3: meaning for every additional copy of the minor allele that you carry, your trait value will increase by 3 units (plus or minus some random noise).\n\n```{r simulate-trait}\n# simulate trait\nset.seed(494) # set seed for reproducibility\nn <- nrow(X) # calculate the number of individuals \ny <- 3 * X[,'rs2476601'] + rnorm(n, 0, 1) # y = 2 * x + e\n\n# look at the first few simulated trait values\nhead(y)\n```\n\nNow we know by design that our trait `y` depends on SNP rs10181821! We will use this information later to see how well our methods are working. We'll now refer to rs10181821 as the *causal SNP*. \n\n## Quality control\n\nBefore running our GWAS we should make sure our data is up for the task! \n\nTo start, we need to filter *monomorphic* SNPs. This means meaning everyone has the same genotype, and without variation, we can't estimate an association with a trait. \n\nSince these SNPs provide no useful information, we’ll remove them by filtering out those with a MAF of zero.\n\n```{r remove-mono-from-map}\n# keep only those SNPs with MAF > 0\nmap.clean <- hapmap$map %>%\n  filter(MAF > 0)\n```\n\n**How many SNPs are left after filtering? How many did we remove?**\n\n```{r}\n# check dimensions after filtering\ndim(map.clean)\n\n# compare to original dimensions\ndim(hapmap$map)\n```\nNote we have dropped 174146 SNPs!\n\nNow, let's remove these monomorphic SNPs from our genotype matrix (`X`)\n\n```{r remove-mono-from-genotypes}\n# create vector of which SNPs have a MAF of 0\nmonomorphic <- which(maf == 0) \nhead(monomorphic) \n\n# remove columns in the monomorphic vector\nX.clean <- X[,-monomorphic]\n```\n\nMake sure to confirm that the new \"clean\" genotype matrix has the correct number of rows and columns before you move on.\n\n```{r check-dimensions}\ndim(X.clean)\n```\n\n::: callout-note\nToday, we're going to restrict our QC to removing monomoprhic SNPs. But note that there are additional QC steps that are normally conducted before GWAS.\n:::\n\n## GWAS\n\nNow, we’re going to loop through each of the SNPs, fitting a linear regression model at each SNP. For each model, we’ll record the estimates (`betas`), standard errors (`ses`), test statistics (`tstats`) and p-values (`pvals`) for the coefficient of interest (the slope).\n\n> This code may take a *long* time to run! \n\n```{r gwas-all-chrom}\n#| cache: true\n\n# set up empty vectors for storing results\nbetas <- c()\nses <- c()\ntstats <- c()\npvals <- c()\n\n# loop through all SNPs\nfor(i in 1:ncol(X.clean)){\n  # print out occasional updates telling us what SNP we're analyzing\n  if(i %% 10000 == 0) print(paste('Analyzing SNP', i)) \n  # fit model\n  mod <- lm(y ~ X.clean[,i])\n  # get coefficient information\n  coefinfo <- tidy(mod)\n  # record estimate, SE, test stat, and p-value\n  betas[i] <- coefinfo$estimate[2]\n  ses[i] <- coefinfo$std.error[2]\n  tstats[i] <- coefinfo$statistic[2]\n  pvals[i] <- coefinfo$p.value[2]\n}\n\n```\n\nWe need to add our results to our map data frame that contains information about each SNP.\n\n```{r all-results}\n# start with the map info for the chr 1 SNPs\nall.results <- map.clean\n\n# then add betas, SEs, etc.\nall.results <- all.results %>%\n  mutate(Estimate = betas,\n         Std.Error = ses,\n         Test.Statistic = tstats,\n         P.Value = pvals)\n\n# look at results\nhead(all.results)\n```\n\n\n## Visualizing Results: Manhattan Plots\n\nWe will use the `qqman` package to create a Manhattan plot and visualize our *genome-wide* association results.\n\n```{r}\n#| cache: true\n\n# Identify genome-wide significant SNPs\nsig.snps <- all.results %>%\n  filter(P.Value < 5e-08) %>% \n  pull(snp.name)\n\n# Generate Manhattan plot\nmanhattan(all.results, \n          chr = \"chromosome\", \n          bp = \"position\", \n          p = \"P.Value\", \n          snp = \"snp.name\", \n          ylim = c(0, 10),\n          col = c('darkblue', 'lightblue'),  # change color scheme\n          highlight = sig.snps,          # Highlight significant SNPs\n          genomewideline = -log10(5e-07),# Adjust genome-wide line, we will see how to determine this indicator in future steps \n          main = \"Manhattan Plot of GWAS Results\")\n```\n\nWe can also created a zoomed-in view for Chromosome 2 to get a closer look at the most significant SNPs\n\n```{r}\n# Zoom into chromosome 1 with annotations\nmanhattan(subset(all.results, chromosome == 1), \n          chr = \"chromosome\", \n          bp = \"position\", \n          p = \"P.Value\", \n          snp = \"snp.name\", \n          ylim = c(0, 20),\n          annotatePval = 5e-10, \n          annotateTop = FALSE,\n          main = \"Zoomed-in View: Chromosome 1\")\n```\n\n:::callout-note\n\n*Understanding the Y-Axis in a Manhattan Plot*\n\nThe **y-axis** in a Manhattan plot represents the **statistical significance** of each SNP’s association with the trait of interest. It is plotted as **$-\\log_{10}(p\\text{-value})$**, meaning:  \n\n- **Higher points indicate stronger evidence** that the SNP is associated with the trait.  \n- A **low p-value (e.g.,  $10^{-8}$)** translates to a **high $-\\log_{10}(p\\text{-value})$ value (e.g., 8)**, making it more noticeable in the plot.  \n:::\n","srcMarkdownNoYaml":"\n\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(echo = TRUE, error = TRUE)\nlibrary(survival)\nlibrary(Matrix)\nlibrary(snpStats)\n```\n\nIn this section we will learn how to perform a Genome-Wide Association study in R using marginal regression, and how to visualize our results using Manhattan plots. \n\n### Preparation\n\nTo prepare for this task you will need to install (or update) the following packages:\n\n```{r load-packages}\n#| message: false\nlibrary(tidyverse)\nlibrary(broom)\nlibrary(qqman)\nlibrary(RColorBrewer)\n```\n\nWe will also need the `snpStats`. The installation process for the package is slightly different:\n\n```{r install-from-bioconductor}\n#| eval: false\n\n# installing the package\nif (!require(\"BiocManager\", quietly = TRUE))\n    install.packages(\"BiocManager\")\n\nBiocManager::install(\"snpStats\")\n\n# load the snpStats package\nlibrary(snpStats)\n```\n\n\n## Data: exploration and prep\n\nWe will be using real genotype data and a simulated binary phenotype from the International HapMap Project, specifically from 165 individuals.The data only includes individuals from Utah with Northern and Western European ancestry (the \"CEU\" population).\n\nThe data is available in the *PLINK format* and are stored in three files:\n\n- `.bed` – genotype information\n- `.fam` – individual-level information\n- `.bim` – SNP details\n\n::: callout-note!\n`PLINK` is a tool for analyzing genetic data and conducting GWAS. Learn more [here](https://www.cog-genomics.org/plink/). We’re going to be conducting our GWAS \"by hand\", but in practice most people use `PLINK` or other software programs instead. \n:::\n\nWe can use the `read.plink` function in the `snpStats` package to read these data into R. \n\n```{r file-paths}\n# update file paths\ngwas.dir <- './1_QC_GWAS/HapMap_3_r3_1'\n\nbed <- paste0(gwas.dir, '.bed')\nbim <- paste0(gwas.dir, '.bim')\nfam <- paste0(gwas.dir, '.fam')\n```\n\n\n```{r read-data}\n#| cache: true\n# NOTE: this might take a minute or two\nhapmap <- snpStats::read.plink(bed, bim, fam)\n\n```\n\n### Understanding the data\n\nThe `hapmap` data object we have created is a \"list\" containing the three items described above. \n\n```{r explore-data}\nclass(hapmap)\nnames(hapmap)\n```\n\nThe dataset contains 165 people and 1,457,897 SNPs\n\n```{r}\ndim(hapmap$genotypes)\n```\n\n\nBut what do we know about each individual? The `fam` file keeps track of information about each of the people in our study, see a glossary below:\n\n```{r explore-sample-info}\nhead(hapmap$fam)\n```\n\n-   `pedigree`: the family ID number, ie the ID of the family, or \"pedigree\", to which this individual belongs\n-   `member`: the individual ID number \n-   `father`: the ID of the individual's father, if known **and** present in this sample (`NA` otherwise)\n-   `mother`: the ID of the individual's mother, if known and present in this sample (`NA` otherwise)\n-   `sex`: binary sex (`1` = male, `2` = female, `0` = unknown)\n-   `affected`: a binary simulated phenotype (`1` = control, `2` = case)\n\nThe `.map` file contains information about the different SNPs: \n\n```{r explore-snp-info}\nhead(hapmap$map)\n```\n\n-   `chromosome`: the chromosome on which the SNP resides\n-   `snp.name`: the name of the SNP (commonly referred to as the \"rsID\")\n-   `cM`: or *centiMorgans*; how far about SNPs are from one another along the genome, also known as \"genetic distance\"\n-   `position`: physical (base pair) distance, position of the SNP (e.g., position = 1 would be the very first nucleotide in our DNA sequence)\n-   `allele.1`: one of the alleles at this SNP (according to the `PLINK` documentation, this is *usually* the minor allele)\n-   `allele.2`: other allele at this SNP (according to the `PLINK` documentation, this is *usually* the major allele)\n\n\n### Format data for analysis \n\nLet's add a minor allele frequencies to our `map` data frame. (This will come in handy later!)\n\n```{r add-MAF-to-SNP-info}\nmaf <- col.summary(hapmap$genotypes)$MAF\n\n# add new MAF variable \nhapmap$map <- hapmap$map %>%\n  mutate(MAF = maf)\n\n# look at SNP info again\nhead(hapmap$map)\n```\n\nThe `snpstats` package uses a unique format to store data. Currently, genotypes are coded as 01, 02, and 03 (with 00 representing missing values). Let's convert this to the 0, 1, 2 (and NA) format \n\n```{r reformat-genotypes}\n# what type of object is hapmap$genotypes\nclass(hapmap$genotypes)\n\n# convert from \"SnpMatrix\" to \"numeric\"\nX <- as(hapmap$genotypes, \"numeric\")\n\n# what type of object do we have now \nclass(X)\n\n# look at first five rows/columns to confirm conversion looks ok\nX[1:5, 1:5]\n```\n\nYou should now see a matrix of 0's, 1's, and 2's!\n\n## Trait Simulation\n\n### Background\n\nFor the purpose of this task, we will create artificial data where we already know the \"truth,\" then run a statistical method on it to see how well it performs.Since we designed the data, we can compare the method’s results to the known truth, allowing us to evaluate its accuracy. \n\nSimulation studies are a widely used technique in statistical research, as they are especially helpful when testing new methods, exploring how they behave in different situations, or comparing multiple approaches. It’s also a great workaround when getting real data can be tricky. \n\n### Picking a causal SNP\n\nLet's simulate a trait that depends on the SNP known as *rs2476601*. Here's what we know about this SNP: \n\n```{r look-at-causal-SNP}\nhapmap$map %>%\n  filter(snp.name == 'rs2476601')\n```\n\n### Simulating a quantitative trait\n\nNow, let's create a quantitative trait `y` that depends on your genotype at this SNP plus some random noise. We'll give this SNP an \"effect size\" of 3: meaning for every additional copy of the minor allele that you carry, your trait value will increase by 3 units (plus or minus some random noise).\n\n```{r simulate-trait}\n# simulate trait\nset.seed(494) # set seed for reproducibility\nn <- nrow(X) # calculate the number of individuals \ny <- 3 * X[,'rs2476601'] + rnorm(n, 0, 1) # y = 2 * x + e\n\n# look at the first few simulated trait values\nhead(y)\n```\n\nNow we know by design that our trait `y` depends on SNP rs10181821! We will use this information later to see how well our methods are working. We'll now refer to rs10181821 as the *causal SNP*. \n\n## Quality control\n\nBefore running our GWAS we should make sure our data is up for the task! \n\nTo start, we need to filter *monomorphic* SNPs. This means meaning everyone has the same genotype, and without variation, we can't estimate an association with a trait. \n\nSince these SNPs provide no useful information, we’ll remove them by filtering out those with a MAF of zero.\n\n```{r remove-mono-from-map}\n# keep only those SNPs with MAF > 0\nmap.clean <- hapmap$map %>%\n  filter(MAF > 0)\n```\n\n**How many SNPs are left after filtering? How many did we remove?**\n\n```{r}\n# check dimensions after filtering\ndim(map.clean)\n\n# compare to original dimensions\ndim(hapmap$map)\n```\nNote we have dropped 174146 SNPs!\n\nNow, let's remove these monomorphic SNPs from our genotype matrix (`X`)\n\n```{r remove-mono-from-genotypes}\n# create vector of which SNPs have a MAF of 0\nmonomorphic <- which(maf == 0) \nhead(monomorphic) \n\n# remove columns in the monomorphic vector\nX.clean <- X[,-monomorphic]\n```\n\nMake sure to confirm that the new \"clean\" genotype matrix has the correct number of rows and columns before you move on.\n\n```{r check-dimensions}\ndim(X.clean)\n```\n\n::: callout-note\nToday, we're going to restrict our QC to removing monomoprhic SNPs. But note that there are additional QC steps that are normally conducted before GWAS.\n:::\n\n## GWAS\n\nNow, we’re going to loop through each of the SNPs, fitting a linear regression model at each SNP. For each model, we’ll record the estimates (`betas`), standard errors (`ses`), test statistics (`tstats`) and p-values (`pvals`) for the coefficient of interest (the slope).\n\n> This code may take a *long* time to run! \n\n```{r gwas-all-chrom}\n#| cache: true\n\n# set up empty vectors for storing results\nbetas <- c()\nses <- c()\ntstats <- c()\npvals <- c()\n\n# loop through all SNPs\nfor(i in 1:ncol(X.clean)){\n  # print out occasional updates telling us what SNP we're analyzing\n  if(i %% 10000 == 0) print(paste('Analyzing SNP', i)) \n  # fit model\n  mod <- lm(y ~ X.clean[,i])\n  # get coefficient information\n  coefinfo <- tidy(mod)\n  # record estimate, SE, test stat, and p-value\n  betas[i] <- coefinfo$estimate[2]\n  ses[i] <- coefinfo$std.error[2]\n  tstats[i] <- coefinfo$statistic[2]\n  pvals[i] <- coefinfo$p.value[2]\n}\n\n```\n\nWe need to add our results to our map data frame that contains information about each SNP.\n\n```{r all-results}\n# start with the map info for the chr 1 SNPs\nall.results <- map.clean\n\n# then add betas, SEs, etc.\nall.results <- all.results %>%\n  mutate(Estimate = betas,\n         Std.Error = ses,\n         Test.Statistic = tstats,\n         P.Value = pvals)\n\n# look at results\nhead(all.results)\n```\n\n\n## Visualizing Results: Manhattan Plots\n\nWe will use the `qqman` package to create a Manhattan plot and visualize our *genome-wide* association results.\n\n```{r}\n#| cache: true\n\n# Identify genome-wide significant SNPs\nsig.snps <- all.results %>%\n  filter(P.Value < 5e-08) %>% \n  pull(snp.name)\n\n# Generate Manhattan plot\nmanhattan(all.results, \n          chr = \"chromosome\", \n          bp = \"position\", \n          p = \"P.Value\", \n          snp = \"snp.name\", \n          ylim = c(0, 10),\n          col = c('darkblue', 'lightblue'),  # change color scheme\n          highlight = sig.snps,          # Highlight significant SNPs\n          genomewideline = -log10(5e-07),# Adjust genome-wide line, we will see how to determine this indicator in future steps \n          main = \"Manhattan Plot of GWAS Results\")\n```\n\nWe can also created a zoomed-in view for Chromosome 2 to get a closer look at the most significant SNPs\n\n```{r}\n# Zoom into chromosome 1 with annotations\nmanhattan(subset(all.results, chromosome == 1), \n          chr = \"chromosome\", \n          bp = \"position\", \n          p = \"P.Value\", \n          snp = \"snp.name\", \n          ylim = c(0, 20),\n          annotatePval = 5e-10, \n          annotateTop = FALSE,\n          main = \"Zoomed-in View: Chromosome 1\")\n```\n\n:::callout-note\n\n*Understanding the Y-Axis in a Manhattan Plot*\n\nThe **y-axis** in a Manhattan plot represents the **statistical significance** of each SNP’s association with the trait of interest. It is plotted as **$-\\log_{10}(p\\text{-value})$**, meaning:  \n\n- **Higher points indicate stronger evidence** that the SNP is associated with the trait.  \n- A **low p-value (e.g.,  $10^{-8}$)** translates to a **high $-\\log_{10}(p\\text{-value})$ value (e.g., 8)**, making it more noticeable in the plot.  \n:::\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["styles.css"],"toc":true,"output-file":"gwas_implementation.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.6.42","editor":"visual","theme":"lux","title":"GWAS Implementation"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}