{
  "hash": "c2c89dbf842e1f2a8c76b0eefe457acd",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"GWAS Implementation\"\nformat: html\n---\n\n\n\n\n\nIn this section we will learn how to perform a Genome-Wide Association study in R using marginal regression, and how to visualize our results using Manhattan plots. \n\n### Preparation\n\nTo prepare for this task you will need to install (or update) the following packages:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(broom)\nlibrary(qqman)\nlibrary(RColorBrewer)\n```\n:::\n\n\n\nWe will also need the `snpStats`. The installation process for the package is slightly different:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# installing the package\nif (!require(\"BiocManager\", quietly = TRUE))\n    install.packages(\"BiocManager\")\n\nBiocManager::install(\"snpStats\")\n\n# load the snpStats package\nlibrary(snpStats)\n```\n:::\n\n\n\n\n## Data: exploration and prep\n\nWe will be using real genotype data and a simulated binary phenotype from the International HapMap Project, specifically from 165 individuals.The data only includes individuals from Utah with Northern and Western European ancestry (the \"CEU\" population).\n\nThe data is available in the *PLINK format* and are stored in three files:\n\n- `.bed` – genotype information\n- `.fam` – individual-level information\n- `.bim` – SNP details\n\n::: callout-note!\n`PLINK` is a tool for analyzing genetic data and conducting GWAS. Learn more [here](https://www.cog-genomics.org/plink/). We’re going to be conducting our GWAS \"by hand\", but in practice most people use `PLINK` or other software programs instead. \n:::\n\nWe can use the `read.plink` function in the `snpStats` package to read these data into R. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# update file paths\ngwas.dir <- './1_QC_GWAS/HapMap_3_r3_1'\n\nbed <- paste0(gwas.dir, '.bed')\nbim <- paste0(gwas.dir, '.bim')\nfam <- paste0(gwas.dir, '.fam')\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# NOTE: this might take a minute or two\nhapmap <- snpStats::read.plink(bed, bim, fam)\n```\n:::\n\n\n\n### Understanding the data\n\nThe `hapmap` data object we have created is a \"list\" containing the three items described above. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(hapmap)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"list\"\n```\n\n\n:::\n\n```{.r .cell-code}\nnames(hapmap)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"genotypes\" \"fam\"       \"map\"      \n```\n\n\n:::\n:::\n\n\n\nThe dataset contains 165 people and 1,457,897 SNPs\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndim(hapmap$genotypes)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]     165 1457897\n```\n\n\n:::\n:::\n\n\n\n\nBut what do we know about each individual? The `fam` file keeps track of information about each of the people in our study, see a glossary below:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(hapmap$fam)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n        pedigree  member  father  mother sex affected\nNA06989     1328 NA06989    <NA>    <NA>   2        2\nNA11891     1377 NA11891    <NA>    <NA>   1        2\nNA11843     1349 NA11843    <NA>    <NA>   1        1\nNA12341     1330 NA12341    <NA>    <NA>   2        2\nNA12739     1444 NA12739 NA12748 NA12749   1       NA\nNA10850     1344 NA10850    <NA> NA12058   2       NA\n```\n\n\n:::\n:::\n\n\n\n-   `pedigree`: the family ID number, ie the ID of the family, or \"pedigree\", to which this individual belongs\n-   `member`: the individual ID number \n-   `father`: the ID of the individual's father, if known **and** present in this sample (`NA` otherwise)\n-   `mother`: the ID of the individual's mother, if known and present in this sample (`NA` otherwise)\n-   `sex`: binary sex (`1` = male, `2` = female, `0` = unknown)\n-   `affected`: a binary simulated phenotype (`1` = control, `2` = case)\n\nThe `.map` file contains information about the different SNPs: \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(hapmap$map)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           chromosome   snp.name cM position allele.1 allele.2\nrs2185539           1  rs2185539 NA   556738        T        C\nrs11510103          1 rs11510103 NA   557616        G        A\nrs11240767          1 rs11240767 NA   718814        T        C\nrs3131972           1  rs3131972 NA   742584        A        G\nrs3131969           1  rs3131969 NA   744045        A        G\nrs1048488           1  rs1048488 NA   750775        C        T\n```\n\n\n:::\n:::\n\n\n\n-   `chromosome`: the chromosome on which the SNP resides\n-   `snp.name`: the name of the SNP (commonly referred to as the \"rsID\")\n-   `cM`: or *centiMorgans*; how far about SNPs are from one another along the genome, also known as \"genetic distance\"\n-   `position`: physical (base pair) distance, position of the SNP (e.g., position = 1 would be the very first nucleotide in our DNA sequence)\n-   `allele.1`: one of the alleles at this SNP (according to the `PLINK` documentation, this is *usually* the minor allele)\n-   `allele.2`: other allele at this SNP (according to the `PLINK` documentation, this is *usually* the major allele)\n\n\n### Format data for analysis \n\nLet's add a minor allele frequencies to our `map` data frame. (This will come in handy later!)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmaf <- col.summary(hapmap$genotypes)$MAF\n\n# add new MAF variable \nhapmap$map <- hapmap$map %>%\n  mutate(MAF = maf)\n\n# look at SNP info again\nhead(hapmap$map)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           chromosome   snp.name cM position allele.1 allele.2        MAF\nrs2185539           1  rs2185539 NA   556738        T        C 0.00000000\nrs11510103          1 rs11510103 NA   557616        G        A 0.00621118\nrs11240767          1 rs11240767 NA   718814        T        C 0.00000000\nrs3131972           1  rs3131972 NA   742584        A        G 0.15757576\nrs3131969           1  rs3131969 NA   744045        A        G 0.13030303\nrs1048488           1  rs1048488 NA   750775        C        T 0.15853659\n```\n\n\n:::\n:::\n\n\n\nThe `snpstats` package uses a unique format to store data. Currently, genotypes are coded as 01, 02, and 03 (with 00 representing missing values). Let's convert this to the 0, 1, 2 (and NA) format \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# what type of object is hapmap$genotypes\nclass(hapmap$genotypes)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"SnpMatrix\"\nattr(,\"package\")\n[1] \"snpStats\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# convert from \"SnpMatrix\" to \"numeric\"\nX <- as(hapmap$genotypes, \"numeric\")\n\n# what type of object do we have now \nclass(X)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"matrix\" \"array\" \n```\n\n\n:::\n\n```{.r .cell-code}\n# look at first five rows/columns to confirm conversion looks ok\nX[1:5, 1:5]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n        rs2185539 rs11510103 rs11240767 rs3131972 rs3131969\nNA06989         2          2          2         1         1\nNA11891         2          2          2         1         2\nNA11843         2          2          2         2         2\nNA12341         2          2          2         1         1\nNA12739         2          2          2         2         2\n```\n\n\n:::\n:::\n\n\n\nYou should now see a matrix of 0's, 1's, and 2's!\n\n## Trait Simulation\n\n### Background\n\nFor the purpose of this task, we will create artificial data where we already know the \"truth,\" then run a statistical method on it to see how well it performs.Since we designed the data, we can compare the method’s results to the known truth, allowing us to evaluate its accuracy. \n\nSimulation studies are a widely used technique in statistical research, as they are especially helpful when testing new methods, exploring how they behave in different situations, or comparing multiple approaches. It’s also a great workaround when getting real data can be tricky. \n\n### Picking a causal SNP\n\nLet's simulate a trait that depends on the SNP known as *rs2476601*. Here's what we know about this SNP: \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhapmap$map %>%\n  filter(snp.name == 'rs2476601')\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n          chromosome  snp.name cM  position allele.1 allele.2       MAF\nrs2476601          1 rs2476601 NA 114179091        A        G 0.1196319\n```\n\n\n:::\n:::\n\n\n\n### Simulating a quantitative trait\n\nNow, let's create a quantitative trait `y` that depends on your genotype at this SNP plus some random noise. We'll give this SNP an \"effect size\" of 3: meaning for every additional copy of the minor allele that you carry, your trait value will increase by 3 units (plus or minus some random noise).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# simulate trait\nset.seed(494) # set seed for reproducibility\nn <- nrow(X) # calculate the number of individuals \ny <- 3 * X[,'rs2476601'] + rnorm(n, 0, 1) # y = 2 * x + e\n\n# look at the first few simulated trait values\nhead(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n NA06989  NA11891  NA11843  NA12341  NA12739  NA10850 \n1.208268 5.626781 5.342265 2.169640 4.945083 6.835045 \n```\n\n\n:::\n:::\n\n\n\nNow we know by design that our trait `y` depends on SNP rs10181821! We will use this information later to see how well our methods are working. We'll now refer to rs10181821 as the *causal SNP*. \n\n## Quality control\n\nBefore running our GWAS we should make sure our data is up for the task! \n\nTo start, we need to filter *monomorphic* SNPs. This means meaning everyone has the same genotype, and without variation, we can't estimate an association with a trait. \n\nSince these SNPs provide no useful information, we’ll remove them by filtering out those with a MAF of zero.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# keep only those SNPs with MAF > 0\nmap.clean <- hapmap$map %>%\n  filter(MAF > 0)\n```\n:::\n\n\n\n**How many SNPs are left after filtering? How many did we remove?**\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# check dimensions after filtering\ndim(map.clean)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1283751       7\n```\n\n\n:::\n\n```{.r .cell-code}\n# compare to original dimensions\ndim(hapmap$map)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1457897       7\n```\n\n\n:::\n:::\n\n\nNote we have dropped 174146 SNPs!\n\nNow, let's remove these monomorphic SNPs from our genotype matrix (`X`)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# create vector of which SNPs have a MAF of 0\nmonomorphic <- which(maf == 0) \nhead(monomorphic) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  1  3 10 11 12 17\n```\n\n\n:::\n\n```{.r .cell-code}\n# remove columns in the monomorphic vector\nX.clean <- X[,-monomorphic]\n```\n:::\n\n\n\nMake sure to confirm that the new \"clean\" genotype matrix has the correct number of rows and columns before you move on.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndim(X.clean)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]     165 1283751\n```\n\n\n:::\n:::\n\n\n\n::: callout-note\nToday, we're going to restrict our QC to removing monomoprhic SNPs. But note that there are additional QC steps that are normally conducted before GWAS.\n:::\n\n## GWAS\n\nNow, we’re going to loop through each of the SNPs, fitting a linear regression model at each SNP. For each model, we’ll record the estimates (`betas`), standard errors (`ses`), test statistics (`tstats`) and p-values (`pvals`) for the coefficient of interest (the slope).\n\n> This code may take a *long* time to run! \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# set up empty vectors for storing results\nbetas <- c()\nses <- c()\ntstats <- c()\npvals <- c()\n\n# loop through all SNPs\nfor(i in 1:ncol(X.clean)){\n  # print out occasional updates telling us what SNP we're analyzing\n  if(i %% 10000 == 0) print(paste('Analyzing SNP', i)) \n  # fit model\n  mod <- lm(y ~ X.clean[,i])\n  # get coefficient information\n  coefinfo <- tidy(mod)\n  # record estimate, SE, test stat, and p-value\n  betas[i] <- coefinfo$estimate[2]\n  ses[i] <- coefinfo$std.error[2]\n  tstats[i] <- coefinfo$statistic[2]\n  pvals[i] <- coefinfo$p.value[2]\n}\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError: object 'X.clean' not found\n```\n\n\n:::\n:::\n\n\n\nWe need to add our results to our map data frame that contains information about each SNP.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# start with the map info for the chr 1 SNPs\nall.results <- map.clean\n\n# then add betas, SEs, etc.\nall.results <- all.results %>%\n  mutate(Estimate = betas,\n         Std.Error = ses,\n         Test.Statistic = tstats,\n         P.Value = pvals)\n\n# look at results\nhead(all.results)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           chromosome   snp.name cM position allele.1 allele.2        MAF\nrs11510103          1 rs11510103 NA   557616        G        A 0.00621118\nrs3131972           1  rs3131972 NA   742584        A        G 0.15757576\nrs3131969           1  rs3131969 NA   744045        A        G 0.13030303\nrs1048488           1  rs1048488 NA   750775        C        T 0.15853659\nrs12562034          1 rs12562034 NA   758311        A        G 0.10909091\nrs12124819          1 rs12124819 NA   766409        G        A 0.28658537\n```\n\n\n:::\n:::\n\n\n\n\n## Visualizing Results: Manhattan Plots\n\nWe will use the `qqman` package to create a Manhattan plot and visualize our *genome-wide* association results.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Identify genome-wide significant SNPs\nsig.snps <- all.results %>%\n  filter(P.Value < 5e-08) %>% \n  pull(snp.name)\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError: object 'all.results' not found\n```\n\n\n:::\n\n```{.r .cell-code}\n# Generate Manhattan plot\nmanhattan(all.results, \n          chr = \"chromosome\", \n          bp = \"position\", \n          p = \"P.Value\", \n          snp = \"snp.name\", \n          ylim = c(0, 10),\n          col = c('darkblue', 'lightblue'),  # change color scheme\n          highlight = sig.snps,          # Highlight significant SNPs\n          genomewideline = -log10(5e-07),# Adjust genome-wide line, we will see how to determine this indicator in future steps \n          main = \"Manhattan Plot of GWAS Results\")\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError: object 'all.results' not found\n```\n\n\n:::\n:::\n\n\n\nWe can also created a zoomed-in view for Chromosome 2 to get a closer look at the most significant SNPs\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Zoom into chromosome 1 with annotations\nmanhattan(subset(all.results, chromosome == 1), \n          chr = \"chromosome\", \n          bp = \"position\", \n          p = \"P.Value\", \n          snp = \"snp.name\", \n          ylim = c(0, 20),\n          annotatePval = 5e-10, \n          annotateTop = FALSE,\n          main = \"Zoomed-in View: Chromosome 1\")\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in manhattan(subset(all.results, chromosome == 1), chr = \"chromosome\", : Column P.Value not found!\n```\n\n\n:::\n:::\n\n\n\n:::callout-note\n\n*Understanding the Y-Axis in a Manhattan Plot*\n\nThe **y-axis** in a Manhattan plot represents the **statistical significance** of each SNP’s association with the trait of interest. It is plotted as **$-\\log_{10}(p\\text{-value})$**, meaning:  \n\n- **Higher points indicate stronger evidence** that the SNP is associated with the trait.  \n- A **low p-value (e.g.,  $10^{-8}$)** translates to a **high $-\\log_{10}(p\\text{-value})$ value (e.g., 8)**, making it more noticeable in the plot.  \n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}